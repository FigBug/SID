/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================
SIDEngine::SIDEngine (SIDAudioProcessor& p)
    : processor (p)
{
}

void SIDEngine::prepareToPlay (double sampleRate)
{
    sid.reset();
    sid.set_chip_model (MOS6581);
    sid.set_sampling_parameters (1022730, SAMPLE_INTERPOLATE, sampleRate);
}

int SIDEngine::parameterIntValue (const juce::String& uid)
{
    return processor.parameterIntValue (uid);
}

float SIDEngine::parameterValue (const juce::String& uid)
{
    return processor.parameterValue (uid);
}

bool SIDEngine::parameterBoolValue (const juce::String& uid)
{
    return processor.parameterBoolValue (uid);
}

void SIDEngine::runUntil (int& done, juce::AudioSampleBuffer& buffer, int pos)
{
    int todo = std::min (pos, buffer.getNumSamples()) - done;

    while (todo > 0)
    {
        cycle_count clock = 64;
        while (clock && todo > 0)
        {
            short out[1024];
            int count = sid.clock (clock, out, std::min (todo, 1024));

            float* data = buffer.getWritePointer (0, done);
            for (int i = 0; i < count; i++)
                data[i] += out[i] / 32768.0f;

            done += count;
            todo -= count;
        }
    }
}

void SIDEngine::processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer& midi)
{
    buffer.clear();

    // Update the filters
    uint8_t reg;

    reg = parameterIntValue (SIDAudioProcessor::paramCutoff) & 0x7;
    writeReg (0x15, reg);

    reg = uint8_t (parameterIntValue (SIDAudioProcessor::paramCutoff) >> 3);
    writeReg (0x16, reg);

    reg = uint8_t (parameterIntValue (SIDAudioProcessor::paramReso) << 4 |
                   parameterIntValue (SIDAudioProcessor::paramFilter3) << 2 |
                   parameterIntValue (SIDAudioProcessor::paramFilter2) << 1 |
                   parameterIntValue (SIDAudioProcessor::paramFilter1) << 0);

    writeReg (0x17, reg);

    reg = uint8_t ((parameterIntValue (SIDAudioProcessor::paramOutput3) ? 0 : 1) << 7 |
                    parameterIntValue(SIDAudioProcessor::paramHP) << 6 |
                    parameterIntValue(SIDAudioProcessor::paramBP) << 5 |
                    parameterIntValue(SIDAudioProcessor::paramLP) << 4 |
                    parameterIntValue (SIDAudioProcessor::paramVol));

    writeReg (0x18, reg);

    updateOscs (lastNote);

    int done = 0;
    runUntil (done, buffer, 0);

    for (auto itr : midi)
    {
        auto msg = itr.getMessage();
        int pos = itr.samplePosition;

        bool updateBend = false;
        runUntil (done, buffer, pos);

        if (msg.isNoteOn())
        {
            noteQueue.add (msg.getNoteNumber());
            velocity = msg.getVelocity();
        }
        else if (msg.isNoteOff())
        {
            noteQueue.removeFirstMatchingValue (msg.getNoteNumber());
        }
        else if (msg.isAllNotesOff())
        {
            noteQueue.clear();
            pitchBend = 0;
        }
        else if (msg.isPitchWheel())
        {
            updateBend = true;
            pitchBend = (msg.getPitchWheelValue() - 8192) / 8192.0f * 2;
        }

        const int curNote = noteQueue.size() > 0 ? noteQueue.getLast() : -1;

        if (updateBend)
        {
            float freq;
            int period;

            // set freq 1
            freq = float (gin::getMidiNoteInHertz (curNote + pitchBend + parameterValue (SIDAudioProcessor::paramTune1) + parameterValue (SIDAudioProcessor::paramFine1) / 100.0f));
            period = int (freq * (14 * std::pow (2, 24)) / 14318182);

            writeReg (0x00, period & 0xFF);
            writeReg (0x01, period >> 8);

            // set freq
            freq = float (gin::getMidiNoteInHertz (curNote + pitchBend + parameterValue (SIDAudioProcessor::paramTune2) + parameterValue (SIDAudioProcessor::paramFine2) / 100.0f));
            period = int (freq * (14 * pow (2, 24)) / 14318182);

            writeReg (0x07, period & 0xFF);
            writeReg (0x08, period >> 8);

            // set freq 3
            freq = float (gin::getMidiNoteInHertz (curNote + pitchBend + parameterValue (SIDAudioProcessor::paramTune3) + parameterValue (SIDAudioProcessor::paramFine3) / 100.0f));
            period = int (freq * (14 * std::pow (2, 24)) / 14318182);

            writeReg (0x0E, period & 0xFF);
            writeReg (0x0F, period >> 8);
        }

        if (updateBend || lastNote != curNote)
        {
            updateOscs (curNote);
            lastNote = curNote;
        }
    }

    int numSamples = buffer.getNumSamples();
    runUntil (done, buffer, numSamples);
}

void SIDEngine::updateOscs (int curNote)
{
    // Channel 1
    if (curNote != -1 && parameterIntValue (SIDAudioProcessor::paramWave1))
    {
        // set adsr
        int a = parameterIntValue (SIDAudioProcessor::paramA1);
        int d = parameterIntValue (SIDAudioProcessor::paramD1);
        int s = parameterIntValue (SIDAudioProcessor::paramS1);
        int r = parameterIntValue (SIDAudioProcessor::paramR1);

        writeReg (0x05, (a << 4) | d);
        writeReg (0x06, (s << 4) | r);

        // set duty
        int duty = 4095 - parameterIntValue (SIDAudioProcessor::paramPulseWidth1);
        writeReg (0x02, duty & 0xFF);
        writeReg (0x03, duty >> 8);

        // set freq
        float freq = float (gin::getMidiNoteInHertz (curNote + pitchBend + parameterValue (SIDAudioProcessor::paramTune1) + parameterValue (SIDAudioProcessor::paramFine1) / 100.0f));
        int period = int (freq * (14 * pow (2, 24)) / 14318182);

        writeReg (0x00, period & 0xFF);
        writeReg (0x01, period >> 8);

        // set wave on
        uint8_t waveType = uint8_t (parameterIntValue (SIDAudioProcessor::paramWave1));
        uint8_t sync = parameterBoolValue (SIDAudioProcessor::paramSync1) ? 0x02 : 0x00;
        uint8_t ring = parameterBoolValue (SIDAudioProcessor::paramRing1) ? 0x04 : 0x00;
        uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
        writeReg (0x04, (wave << 4) | sync | ring | 0x01);
    }
    else
    {
        // set wave off
        uint8_t waveType = uint8_t (parameterIntValue (SIDAudioProcessor::paramWave1));
        uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
        writeReg (0x04, (wave << 4) | 0x00);
    }

    // Channel 2
    if (curNote != -1 && parameterIntValue (SIDAudioProcessor::paramWave2))
    {
        // set adsr
        int a = parameterIntValue (SIDAudioProcessor::paramA2);
        int d = parameterIntValue (SIDAudioProcessor::paramD2);
        int s = parameterIntValue (SIDAudioProcessor::paramS2);
        int r = parameterIntValue (SIDAudioProcessor::paramR2);

        writeReg (0x0C, (a << 4) | d);
        writeReg (0x0D, (s << 4) | r);

        // set duty
        int duty = 4095 - parameterIntValue (SIDAudioProcessor::paramPulseWidth2);
        writeReg (0x09, duty & 0xFF);
        writeReg (0x0A, duty >> 8);

        // set freq
        float freq = float (gin::getMidiNoteInHertz (curNote + pitchBend + parameterValue (SIDAudioProcessor::paramTune2) + parameterValue (SIDAudioProcessor::paramFine2) / 100.0f));
        int period = int (freq * (14 * pow (2, 24)) / 14318182);

        writeReg (0x07, period & 0xFF);
        writeReg (0x08, period >> 8);

        // set wave on
        uint8_t waveType = uint8_t (parameterIntValue (SIDAudioProcessor::paramWave2));
        uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
        uint8_t sync = parameterIntValue (SIDAudioProcessor::paramSync2) ? 0x02 : 0x00;
        uint8_t ring = parameterIntValue (SIDAudioProcessor::paramRing2) ? 0x04 : 0x00;
        writeReg (0x0B, (wave << 4) | sync | ring | 0x01);
    }
    else
    {
        // set wave off
        uint8_t waveType = uint8_t (parameterIntValue (SIDAudioProcessor::paramWave2));
        uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
        writeReg (0x0B, (wave << 4) | 0x00);
    }

    // Channel 3
    if (curNote != -1 && parameterIntValue (SIDAudioProcessor::paramWave3))
    {
        // set adsr
        int a = parameterIntValue (SIDAudioProcessor::paramA3);
        int d = parameterIntValue (SIDAudioProcessor::paramD3);
        int s = parameterIntValue (SIDAudioProcessor::paramS3);
        int r = parameterIntValue (SIDAudioProcessor::paramR3);

        writeReg (0x13, (a << 4) | d);
        writeReg (0x14, (s << 4) | r);

        // set duty
        int duty = 4095 - parameterIntValue (SIDAudioProcessor::paramPulseWidth3);
        writeReg (0x10, duty & 0xFF);
        writeReg (0x11, duty >> 8);

        // set freq
        float freq = float (gin::getMidiNoteInHertz (curNote + pitchBend + parameterValue (SIDAudioProcessor::paramTune3) + parameterValue (SIDAudioProcessor::paramFine3) / 100.0f));
        int period = int (freq * (14 * pow (2, 24)) / 14318182);

        writeReg (0x0E, period & 0xFF);
        writeReg (0x0F, period >> 8);

        // set wave on
        uint8_t waveType = uint8_t (parameterIntValue (SIDAudioProcessor::paramWave3));
        uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
        uint8_t sync = parameterIntValue (SIDAudioProcessor::paramSync3) ? 0x02 : 0x00;
        uint8_t ring = parameterIntValue (SIDAudioProcessor::paramRing3) ? 0x04 : 0x00;
        writeReg (0x12, (wave << 4) | sync | ring | 0x01);
    }
    else
    {
        // set wave off
        uint8_t waveType = uint8_t (parameterIntValue (SIDAudioProcessor::paramWave3));
        uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
        writeReg (0x12, (wave << 4) | 0x00);
    }
}

void SIDEngine::writeReg (uint8_t reg, uint8_t value)
{
    auto itr = regCache.find (reg);
    if (itr == regCache.end())
    {
        regCache[reg] = value;
        sid.write (reg, value);
    }
    else if (itr->second != value)
    {
        regCache[reg] = value;
        sid.write (reg, value);
    }
}

void SIDEngine::prepareBlock (juce::AudioSampleBuffer& buffer)
{
    // Update the filters
    uint8_t reg;

    reg = parameterIntValue (SIDAudioProcessor::paramCutoff) & 0x7;
    writeReg (0x15, reg);

    reg = uint8_t (parameterIntValue (SIDAudioProcessor::paramCutoff) >> 3);
    writeReg (0x16, reg);

    reg = uint8_t (parameterIntValue (SIDAudioProcessor::paramReso) << 4 |
                   parameterIntValue (SIDAudioProcessor::paramFilter3) << 2 |
                   parameterIntValue (SIDAudioProcessor::paramFilter2) << 1 |
                   parameterIntValue (SIDAudioProcessor::paramFilter1) << 0);

    writeReg (0x17, reg);

    reg = uint8_t ((parameterIntValue (SIDAudioProcessor::paramOutput3) ? 0 : 1) << 7 |
                    parameterIntValue(SIDAudioProcessor::paramHP) << 6 |
                    parameterIntValue(SIDAudioProcessor::paramBP) << 5 |
                    parameterIntValue(SIDAudioProcessor::paramLP) << 4 |
                    parameterIntValue (SIDAudioProcessor::paramVol));

    writeReg (0x18, reg);

    updateOscs (lastNote);

    int done = 0;
    runUntil (done, buffer, 0);
}

void SIDEngine::reset()
{
    sid.reset();
}

void SIDEngine::handleMessage (const juce::MidiMessage& msg)
{
    bool updateBend = false;

    if (msg.isNoteOn())
    {
        noteQueue.add (msg.getNoteNumber());
    }
    else if (msg.isNoteOff())
    {
        noteQueue.removeFirstMatchingValue (msg.getNoteNumber());
    }
    else if (msg.isAllNotesOff())
    {
        noteQueue.clear();
    }
    else if (msg.isPitchWheel())
    {
        updateBend = true;
        pitchBend = (msg.getPitchWheelValue() - 8192) / 8192.0f * 2;
    }
    const int curNote = noteQueue.size() > 0 ? noteQueue.getLast() : -1;

    if (updateBend)
    {
        float freq;
        int period;

        // set freq 1
        freq = float (gin::getMidiNoteInHertz (curNote + pitchBend + parameterValue (SIDAudioProcessor::paramTune1) + parameterValue (SIDAudioProcessor::paramFine1) / 100.0f));
        period = int (freq * (14 * std::pow (2, 24)) / 14318182);

        writeReg (0x00, period & 0xFF);
        writeReg (0x01, period >> 8);

        // set freq
        freq = float (gin::getMidiNoteInHertz (curNote + pitchBend + parameterValue (SIDAudioProcessor::paramTune2) + parameterValue (SIDAudioProcessor::paramFine2) / 100.0f));
        period = int (freq * (14 * pow (2, 24)) / 14318182);

        writeReg (0x07, period & 0xFF);
        writeReg (0x08, period >> 8);

        // set freq 3
        freq = float (gin::getMidiNoteInHertz (curNote + pitchBend + parameterValue (SIDAudioProcessor::paramTune3) + parameterValue (SIDAudioProcessor::paramFine3) / 100.0f));
        period = int (freq * (14 * std::pow (2, 24)) / 14318182);

        writeReg (0x0E, period & 0xFF);
        writeReg (0x0F, period >> 8);
    }

    if (updateBend || curNote != lastNote)
    {
        updateOscs (curNote);
        lastNote = curNote;
    }
}

//==============================================================================
juce::String SIDAudioProcessor::paramPulseWidth1 = "pw1";
juce::String SIDAudioProcessor::paramWave1       = "w1";
juce::String SIDAudioProcessor::paramA1          = "a1";
juce::String SIDAudioProcessor::paramD1          = "d1";
juce::String SIDAudioProcessor::paramS1          = "s1";
juce::String SIDAudioProcessor::paramR1          = "r1";
juce::String SIDAudioProcessor::paramTune1       = "tune1";
juce::String SIDAudioProcessor::paramFine1       = "fine1";
juce::String SIDAudioProcessor::paramSync1       = "sync1";
juce::String SIDAudioProcessor::paramRing1       = "ring1";
juce::String SIDAudioProcessor::paramPulseWidth2 = "pw2";
juce::String SIDAudioProcessor::paramWave2       = "w2";
juce::String SIDAudioProcessor::paramA2          = "a2";
juce::String SIDAudioProcessor::paramD2          = "d2";
juce::String SIDAudioProcessor::paramS2          = "s2";
juce::String SIDAudioProcessor::paramR2          = "r2";
juce::String SIDAudioProcessor::paramTune2       = "tune2";
juce::String SIDAudioProcessor::paramFine2       = "fine2";
juce::String SIDAudioProcessor::paramSync2       = "sync2";
juce::String SIDAudioProcessor::paramRing2       = "ring2";
juce::String SIDAudioProcessor::paramPulseWidth3 = "pw3";
juce::String SIDAudioProcessor::paramWave3       = "w3";
juce::String SIDAudioProcessor::paramA3          = "a3";
juce::String SIDAudioProcessor::paramD3          = "d3";
juce::String SIDAudioProcessor::paramS3          = "s3";
juce::String SIDAudioProcessor::paramR3          = "r3";
juce::String SIDAudioProcessor::paramTune3       = "tune3";
juce::String SIDAudioProcessor::paramFine3       = "fine3";
juce::String SIDAudioProcessor::paramSync3       = "sync3";
juce::String SIDAudioProcessor::paramRing3       = "ring3";
juce::String SIDAudioProcessor::paramCutoff      = "cutoff";
juce::String SIDAudioProcessor::paramReso        = "reso";
juce::String SIDAudioProcessor::paramFilter1     = "f1";
juce::String SIDAudioProcessor::paramFilter2     = "f2";
juce::String SIDAudioProcessor::paramFilter3     = "f3";
juce::String SIDAudioProcessor::paramLP          = "lowpass";
juce::String SIDAudioProcessor::paramBP          = "bandpass";
juce::String SIDAudioProcessor::paramHP          = "highpass";
juce::String SIDAudioProcessor::paramVol         = "vol";
juce::String SIDAudioProcessor::paramOutput3     = "output3";
juce::String SIDAudioProcessor::paramVoices      = "voices";

//==============================================================================
juce::String percentTextFunction (const gin::Parameter& p, float userValue)
{
    return juce::String::formatted ("%.0f%%", userValue / p.getUserRangeEnd() * 100);
}

juce::String wholeNumberTextFunction (const gin::Parameter&, float userValue)
{
    return juce::String::formatted ("%.0f", userValue);
}

juce::String dutyCycleTextFunction (const gin::Parameter&, float userValue)
{
    return juce::String::formatted ("%.0f%%", userValue / 4095.0 * 100);
}

juce::String typeTextFunction (const gin::Parameter&, float userValue)
{
    return userValue > 0.0f ? "White" : "Periodic";
}

juce::String filterTextFunction (const gin::Parameter&, float userValue)
{
    return userValue > 0.0f ? "Filter" : "Bypass";
}

juce::String onOffTextFunction (const gin::Parameter&, float userValue)
{
    return userValue > 0.0f ? "On" : "Off";
}

juce::String waveTextFunction (const gin::Parameter&, float userValue)
{
    switch (int (userValue))
    {
        case 0: return "Off";
        case 1: return "Triangle";
        case 2: return "Saw";
        case 3: return "Square";
        case 4: return "Noise";
    }
    return "";
}

juce::String aTextFunction (const gin::Parameter&, float userValue)
{
    switch (int (userValue))
    {
        case 0: return "2 ms";
        case 1: return "8 ms";
        case 2: return "16 ms";
        case 3: return "24 ms";
        case 4: return "38 ms";
        case 5: return "56 ms";
        case 6: return "68 ms";
        case 7: return "80 ms";
        case 8: return "100 ms";
        case 9: return "240 ms";
        case 10: return "500 ms";
        case 11: return "800 ms";
        case 12: return "1 s";
        case 13: return "3 s";
        case 14: return "5 s";
        case 15: return "8 s";
        default: return "";
    }
}

juce::String drTextFunction (const gin::Parameter&, float userValue)
{
    switch (int (userValue))
    {
        case 0: return "6 ms";
        case 1: return "24 ms";
        case 2: return "48 ms";
        case 3: return "72 ms";
        case 4: return "114 ms";
        case 5: return "168 ms";
        case 6: return "204 ms";
        case 7: return "240 ms";
        case 8: return "300 ms";
        case 9: return "750 ms";
        case 10: return "1.5 s";
        case 11: return "2.4 s";
        case 12: return "3 s";
        case 13: return "9 s";
        case 14: return "15 s";
        case 15: return "24 s";
        default: return "";
    }
}

juce::String sTextFunction (const gin::Parameter&, float userValue)
{
    return juce::String::formatted ("%.0f%%", userValue / 15 * 100);
}

//==============================================================================
SIDAudioProcessor::SIDAudioProcessor()
    : gin::Processor (false, gin::ProcessorOptions().withAdditionalCredits({"Dag Lem"}))
{
    auto cutoffTextFunction = [this] (const gin::Parameter&, float userValue) -> juce::String
    {
        return juce::String::formatted ("%d Hz", sids[0]->regToCutoff (reg16 (userValue)));
    };

    addExtParam (paramWave1,        "Pulse 1 Wave",       "Wave",       "", {    0.0f,    4.0f, 1.0f, 1.0f },    1.0f, 0.0f, waveTextFunction);
    addExtParam (paramPulseWidth1,  "Pulse 1 Pulse Width","PW",         "", {    0.0f, 4095.0f, 1.0f, 1.0f }, 2048.0f, 0.0f, dutyCycleTextFunction);
    addExtParam (paramA1,           "Pulse 1 A",          "A",          "", {    0.0f,   15.0f, 1.0f, 1.0f },    4.0f, 0.0f, aTextFunction);
    addExtParam (paramD1,           "Pulse 1 D",          "D",          "", {    0.0f,   15.0f, 1.0f, 1.0f },    4.0f, 0.0f, drTextFunction);
    addExtParam (paramS1,           "Pulse 1 S",          "S",          "", {    0.0f,   15.0f, 1.0f, 1.0f },    8.0f, 0.0f, sTextFunction);
    addExtParam (paramR1,           "Pulse 1 R",          "R",          "", {    0.0f,   15.0f, 1.0f, 1.0f },    4.0f, 0.0f, drTextFunction);
    addExtParam (paramTune1,        "Pulse 1 Tune",       "Tune",       "", {  -48.0f,   48.0f, 1.0f, 1.0f },    0.0f, 0.0f, wholeNumberTextFunction);
    addExtParam (paramFine1,        "Pulse 1 Fine",       "Fine",       "", { -100.0f,  100.0f, 1.0f, 1.0f },    0.0f, 0.0f, wholeNumberTextFunction);
    addExtParam (paramSync1,        "Pulse 1 Sync",       "Sync 1<3",   "", {    0.0f,    1.0f, 1.0f, 1.0f },    0.0f, 0.0f, onOffTextFunction);
    addExtParam (paramRing1,        "Pulse 1 Ring",       "Ring 1<3",   "", {    0.0f,    1.0f, 1.0f, 1.0f },    0.0f, 0.0f, onOffTextFunction);
    addExtParam (paramWave2,        "Pulse 2 Wave",       "Wave",       "", {    0.0f,    4.0f, 1.0f, 1.0f },    0.0f, 0.0f, waveTextFunction);
    addExtParam (paramPulseWidth2,  "Pulse 2 Pulse Width","PW",         "", {    0.0f, 4095.0f, 1.0f, 1.0f }, 2048.0f, 0.0f, dutyCycleTextFunction);
    addExtParam (paramA2,           "Pulse 2 A",          "A",          "", {    0.0f,   15.0f, 1.0f, 1.0f },    4.0f, 0.0f, aTextFunction);
    addExtParam (paramD2,           "Pulse 2 D",          "D",          "", {    0.0f,   15.0f, 1.0f, 1.0f },    4.0f, 0.0f, drTextFunction);
    addExtParam (paramS2,           "Pulse 2 S",          "S",          "", {    0.0f,   15.0f, 1.0f, 1.0f },    8.0f, 0.0f, sTextFunction);
    addExtParam (paramR2,           "Pulse 2 R",          "R",          "", {    0.0f,   15.0f, 1.0f, 1.0f },    4.0f, 0.0f, drTextFunction);
    addExtParam (paramTune2,        "Pulse 2 Tune",       "Tune",       "", {  -48.0f,   48.0f, 1.0f, 1.0f },    0.0f, 0.0f, wholeNumberTextFunction);
    addExtParam (paramFine2,        "Pulse 2 Fine",       "Fine",       "", { -100.0f,  100.0f, 1.0f, 1.0f },    0.0f, 0.0f, wholeNumberTextFunction);
    addExtParam (paramSync2,        "Pulse 2 Sync",       "Sync 2<1",   "", {    0.0f,    1.0f, 1.0f, 1.0f },    0.0f, 0.0f, onOffTextFunction);
    addExtParam (paramRing2,        "Pulse 2 Ring",       "Ring 2<1",   "", {    0.0f,    1.0f, 1.0f, 1.0f },    0.0f, 0.0f, onOffTextFunction);
    addExtParam (paramWave3,        "Pulse 3 Wave",       "Wave",       "", {    0.0f,    4.0f, 1.0f, 1.0f },    0.0f, 0.0f, waveTextFunction);
    addExtParam (paramPulseWidth3,  "Pulse 3 Pulse Width","PW",         "", {    0.0f, 4095.0f, 1.0f, 1.0f }, 2048.0f, 0.0f, dutyCycleTextFunction);
    addExtParam (paramA3,           "Pulse 3 A",          "A",          "", {    0.0f,   15.0f, 1.0f, 1.0f },    4.0f, 0.0f, aTextFunction);
    addExtParam (paramD3,           "Pulse 3 D",          "D",          "", {    0.0f,   15.0f, 1.0f, 1.0f },    4.0f, 0.0f, drTextFunction);
    addExtParam (paramS3,           "Pulse 3 S",          "S",          "", {    0.0f,   15.0f, 1.0f, 1.0f },    8.0f, 0.0f, sTextFunction);
    addExtParam (paramR3,           "Pulse 3 R",          "R",          "", {    0.0f,   15.0f, 1.0f, 1.0f },    4.0f, 0.0f, drTextFunction);
    addExtParam (paramTune3,        "Pulse 3 Tune",       "Tune",       "", {  -48.0f,   48.0f, 1.0f, 1.0f },    0.0f, 0.0f, wholeNumberTextFunction);
    addExtParam (paramFine3,        "Pulse 3 Fine",       "Fine",       "", { -100.0f,  100.0f, 1.0f, 1.0f },    0.0f, 0.0f, wholeNumberTextFunction);
    addExtParam (paramSync3,        "Pulse 3 Sync",       "Sync 3<1",   "", {    0.0f,    1.0f, 1.0f, 1.0f },    0.0f, 0.0f, onOffTextFunction);
    addExtParam (paramRing3,        "Pulse 3 Ring",       "Ring 3<1",   "", {    0.0f,    1.0f, 1.0f, 1.0f },    0.0f, 0.0f, onOffTextFunction);
    addExtParam (paramFilter1,      "Filter Ch 1",        "Ch 1",       "", {    0.0f,    1.0f, 1.0f, 1.0f },    0.0f, 0.0f, filterTextFunction);
    addExtParam (paramFilter2,      "Filter Ch 2",        "Ch 2",       "", {    0.0f,    1.0f, 1.0f, 1.0f },    0.0f, 0.0f, filterTextFunction);
    addExtParam (paramFilter3,      "Filter Ch 3",        "Ch 3",       "", {    0.0f,    1.0f, 1.0f, 1.0f },    0.0f, 0.0f, filterTextFunction);
    addExtParam (paramLP,           "Low Pass",           "LP",         "", {    0.0f,    1.0f, 1.0f, 1.0f },    0.0f, 0.0f, onOffTextFunction);
    addExtParam (paramBP,           "Band Pass",          "BP",         "", {    0.0f,    1.0f, 1.0f, 1.0f },    0.0f, 0.0f, onOffTextFunction);
    addExtParam (paramHP,           "High Pass",          "HP",         "", {    0.0f,    1.0f, 1.0f, 1.0f },    0.0f, 0.0f, onOffTextFunction);
    addExtParam (paramCutoff,       "Cutoff",             "Cutoff",   "Hz", {    0.0f, 2047.0f, 1.0f, 1.0f }, 1024.0f, 0.0f, cutoffTextFunction);
    addExtParam (paramReso,         "Resonance",          "Reso",       "", {    0.0f,   15.0f, 1.0f, 1.0f },    8.0f, 0.0f, percentTextFunction);
    addExtParam (paramVol,          "Volume",             "Volume",     "", {    0.0f,   15.0f, 1.0f, 1.0f },   10.0f, 0.0f, percentTextFunction);
    addExtParam (paramOutput3,      "Output 3",           "Output",     "", {    0.0f,    1.0f, 1.0f, 1.0f },    1.0f, 0.0f, onOffTextFunction);
    addExtParam (paramVoices,       "Voices",             "Voices",     "", {    1.0f,    8.0f, 1.0f, 1.0f },    1.0f, 0.0f, wholeNumberTextFunction);

    for (int i = 0; i < 8; i++)
        sids.add (new SIDEngine (*this));
    
    init();
}

SIDAudioProcessor::~SIDAudioProcessor()
{
}

//==============================================================================
void SIDAudioProcessor::prepareToPlay (double sampleRate, int)
{
    for (auto p : sids)
        p->prepareToPlay (sampleRate);

    outputFilter.setCoefficients (juce::IIRCoefficients::makeHighPass (sampleRate, 10));
}

void SIDAudioProcessor::releaseResources()
{
}

void SIDAudioProcessor::reset()
{
    for (auto p : sids)
        p->reset();
}

void SIDAudioProcessor::processBlock (juce::AudioSampleBuffer& buffer, juce::MidiBuffer& midi)
{
    int numSamples = buffer.getNumSamples();
    buffer.clear();

   #if JUCE_IOS
    keyboardState.processNextMidiBuffer (midi, 0, numSamples, true);
   #endif

    int voices = parameterIntValue (paramVoices);

    if (voices == 1)
    {
        sids[0]->processBlock (buffer, midi);
    }
    else
    {
        int done = 0;

        for (int i = 0; i < voices; i++)
            sids[i]->prepareBlock (buffer);

        for (auto itr : midi)
        {
            auto msg = itr.getMessage();
            int pos = itr.samplePosition;

            runUntil (done, buffer, pos);

            if (msg.isNoteOn())
            {
                if (auto voice = findFreeVoice())
                    voice->handleMessage (msg);
            }
            else if (msg.isNoteOff())
            {
                if (auto voice = findVoiceForNote (msg.getNoteNumber()))
                    voice->handleMessage (msg);
            }
            else if (msg.isAllNotesOff())
            {
                for (int i = 0; i < voices; i++)
                    sids[i]->handleMessage (msg);
            }
            else if (msg.isPitchWheel())
            {
                for (int i = 0; i < voices; i++)
                    sids[i]->handleMessage (msg);
            }
        }

        runUntil (done, buffer, numSamples);
    }

    auto data = buffer.getWritePointer (0);
    outputFilter.processSamples (data, numSamples);

    if (fifo.getFreeSpace() >= numSamples)
        fifo.writeMono (data, numSamples);
}

void SIDAudioProcessor::runUntil (int& done, juce::AudioSampleBuffer& buffer, int pos)
{
    int todo = std::min (pos, buffer.getNumSamples()) - done;

    int voices = parameterIntValue (paramVoices);
    for (int i = 0; i < voices; i++)
    {
        int doneCopy = done;
        sids[i]->runUntil (doneCopy, buffer, pos);
    }

    done += todo;
}

SIDEngine* SIDAudioProcessor::findFreeVoice()
{
    int voices = parameterIntValue (paramVoices);
    for (int i = 0; i < voices; i++)
    {
        int vidx = (nextVoice + i) % voices;
        if (sids[vidx]->getNote() == -1)
        {
            nextVoice = (nextVoice + 1) % voices;
            return sids[vidx];
        }
    }
    return nullptr;
}

SIDEngine* SIDAudioProcessor::findVoiceForNote (int note)
{
    int voices = parameterIntValue (paramVoices);
    for (int i = 0; i < voices; i++)
        if (sids[i]->getNote() == note)
            return sids[i];

    return nullptr;
}

//==============================================================================
bool SIDAudioProcessor::hasEditor() const
{
    return true;
}

juce::AudioProcessorEditor* SIDAudioProcessor::createEditor()
{
    return new SIDAudioProcessorEditor (*this);
}

//==============================================================================
// This creates new instances of the plugin..
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new SIDAudioProcessor();
}
