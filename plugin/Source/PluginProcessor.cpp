/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

const char* SIDAudioProcessor::paramPulseWidth1 = "pw1";
const char* SIDAudioProcessor::paramWave1       = "w1";
const char* SIDAudioProcessor::paramA1          = "a1";
const char* SIDAudioProcessor::paramD1          = "d1";
const char* SIDAudioProcessor::paramS1          = "s1";
const char* SIDAudioProcessor::paramR1          = "r1";
const char* SIDAudioProcessor::paramVol         = "vol";

//==============================================================================
String percentTextFunction (const slParameter& p)
{
    return String::formatted("%.0f%%", p.getUserValue() * 100);
}

String typeTextFunction (const slParameter& p)
{
    return p.getUserValue() > 0.0f ? "White" : "Periodic";
}

String speedTextFunction (const slParameter& p)
{
    switch (int (p.getUserValue()))
    {
        case 0: return "Fast";
        case 1: return "Medium";
        case 2: return "Slow";
        case 3: return "Tone 2";
    }
    return "";
}

//==============================================================================
SIDAudioProcessor::SIDAudioProcessor()
{
    addPluginParameter (new slParameter (paramPulseWidth1,  "Pulse 1 Width",  "Width 1", "", 0.0f, 4095.0f,  1.0f, 2048.0f, 1.0f));
    addPluginParameter (new slParameter (paramWave1,        "Pulse 1 Wave",   "Wave 1",  "", 0.0f, 3.0f,  1.0f, 0.0f, 1.0f));
    addPluginParameter (new slParameter (paramA1,           "Pulse 1 A",      "A 1",     "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f));
    addPluginParameter (new slParameter (paramD1,           "Pulse 1 D",      "D 1",     "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f));
    addPluginParameter (new slParameter (paramS1,           "Pulse 1 S",      "S 1",     "", 0.0f, 15.0f, 1.0f, 8.0f, 1.0f));
    addPluginParameter (new slParameter (paramR1,           "Pulse 1 R",      "R 1",     "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f));
    addPluginParameter (new slParameter (paramVol,          "Volume",         "Volume",  "", 0.0f, 15.0f, 1.0f, 10.0f, 1.0f));
}

SIDAudioProcessor::~SIDAudioProcessor()
{
}

//==============================================================================
void SIDAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    outputSmoothed.reset (sampleRate, 0.05);
    
    sid.set_chip_model (MOS6581);
    
    sid.set_sampling_parameters (1022730, SAMPLE_INTERPOLATE, sampleRate);
}

void SIDAudioProcessor::releaseResources()
{
}

void SIDAudioProcessor::runUntil (int& done, AudioSampleBuffer& buffer, int pos)
{
    int todo = jmin (pos, buffer.getNumSamples()) - done;
    
    while (todo > 0)
    {
        cycle_count clock = 64;
        while (clock)
        {
            short out[1024];
            int count = sid.clock (clock, out, 1024);
            
            float* data = buffer.getWritePointer (0, done);
            for (int i = 0; i < count; i++)
                data[i] = out[i] / 32768.0f;
        
            done += count;
            todo -= count;
        }
    }
}

void SIDAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midi)
{
    int done = 0;
    runUntil (done, buffer, 0);
    
    int pos = 0;
    MidiMessage msg;
    MidiBuffer::Iterator itr (midi);
    while (itr.getNextEvent (msg, pos))
    {
        runUntil (done, buffer, pos);
        
        if (msg.isNoteOn())
        {
            noteQueue.add (msg.getNoteNumber());
            velocity = msg.getVelocity();
        }
        else if (msg.isNoteOff())
        {
            noteQueue.removeFirstMatchingValue (msg.getNoteNumber());
        }
        else if (msg.isAllNotesOff())
        {
            noteQueue.clear();
        }
        
        const int curNote = noteQueue.size() > 0 ? noteQueue.getFirst() : -1;
        
        if (curNote != lastNote)
        {
            // Channel 1
            if (curNote != -1)
            {
                // set adsr
                int a = parameterValue (paramA1);
                int d = parameterValue (paramD1);
                int s = parameterValue (paramS1);
                int r = parameterValue (paramR1);
                
                sid.write (5, (a << 4) | d);
                sid.write (6, (s << 4) | r);
                
                // set duty
                int duty = parameterValue (paramPulseWidth1);
                sid.write (2, duty & 0xFF);
                sid.write (3, duty >> 8);
                
                // set freq
                float freq = MidiMessage::getMidiNoteInHertz (curNote);
                int period = freq * (14 * pow (2, 24)) / 14318182;
                
                sid.write (0x00, period & 0xFF);
                sid.write (0x01, period >> 8);
                
                // set wave on
                uint8_t wave = 1 << ((int) parameterValue (paramWave1));
                sid.write (0x04, (wave << 4) | 0x01);
            }
            else
            {
                // set wave off
                uint8_t wave = 1 << ((int) parameterValue (paramWave1));
                sid.write (0x04, (wave << 4) | 0x00);
            }
            
            sid.write (0x18, parameterIntValue (paramVol));
            
            lastNote = curNote;
        }
    }
    
    runUntil (done, buffer, buffer.getNumSamples());
    
    float* data = buffer.getWritePointer (0);
    
    if (editor)
        editor->scope.addSamples (data, buffer.getNumSamples());
}

//==============================================================================
bool SIDAudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* SIDAudioProcessor::createEditor()
{
    editor = new SIDAudioProcessorEditor (*this);
    return editor;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new SIDAudioProcessor();
}
