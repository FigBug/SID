/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

const char* SIDAudioProcessor::paramPulseWidth1 = "pw1";
const char* SIDAudioProcessor::paramWave1       = "w1";
const char* SIDAudioProcessor::paramA1          = "a1";
const char* SIDAudioProcessor::paramD1          = "d1";
const char* SIDAudioProcessor::paramS1          = "s1";
const char* SIDAudioProcessor::paramR1          = "r1";

const char* SIDAudioProcessor::paramPulseWidth2 = "pw2";
const char* SIDAudioProcessor::paramWave2       = "w2";
const char* SIDAudioProcessor::paramA2          = "a2";
const char* SIDAudioProcessor::paramD2          = "d2";
const char* SIDAudioProcessor::paramS2          = "s2";
const char* SIDAudioProcessor::paramR2          = "r2";

const char* SIDAudioProcessor::paramPulseWidth3 = "pw3";
const char* SIDAudioProcessor::paramWave3       = "w3";
const char* SIDAudioProcessor::paramA3          = "a3";
const char* SIDAudioProcessor::paramD3          = "d3";
const char* SIDAudioProcessor::paramS3          = "s3";
const char* SIDAudioProcessor::paramR3          = "r3";

const char* SIDAudioProcessor::paramVol         = "vol";

//==============================================================================
String percentTextFunction (const slParameter&, float userValue)
{
    return String::formatted ("%.0f%%", userValue * 100);
}

String dutyCycleTextFunction (const slParameter&, float userValue)
{
    return String::formatted ("%.0f%%", userValue / 4095.0 * 100);
}

String typeTextFunction (const slParameter&, float userValue)
{
    return userValue > 0.0f ? "White" : "Periodic";
}

String waveTextFunction (const slParameter&, float userValue)
{
    switch (int (userValue))
    {
        case 0: return "Off";
        case 1: return "Triangle";
        case 2: return "Saw";
        case 3: return "Square";
        case 4: return "Noise";
    }
    return "";
}

String aTextFunction (const slParameter&, float userValue)
{
    switch (int (userValue))
    {
        case 0: return "2 ms";
        case 1: return "8 ms";
        case 2: return "16 ms";
        case 3: return "24 ms";
        case 4: return "38 ms";
        case 5: return "56 ms";
        case 6: return "68 ms";
        case 7: return "80 ms";
        case 8: return "100 ms";
        case 9: return "240 ms";
        case 10: return "500 ms";
        case 11: return "800 ms";
        case 12: return "1 s";
        case 13: return "3 s";
        case 14: return "5 s";
        case 15: return "8 s";
        default: return "";
    }
}

String drTextFunction (const slParameter&, float userValue)
{
    switch (int (userValue))
    {
        case 0: return "6 ms";
        case 1: return "24 ms";
        case 2: return "48 ms";
        case 3: return "72 ms";
        case 4: return "114 ms";
        case 5: return "168 ms";
        case 6: return "204 ms";
        case 7: return "240 ms";
        case 8: return "300 ms";
        case 9: return "750 ms";
        case 10: return "1.5 s";
        case 11: return "2.4 s";
        case 12: return "3 s";
        case 13: return "9 s";
        case 14: return "15 s";
        case 15: return "24 s";
        default: return "";
    }
}

String sTextFunction (const slParameter&, float userValue)
{
    return String::formatted ("%.0f%%", userValue / 15 * 100);
}

//==============================================================================
SIDAudioProcessor::SIDAudioProcessor()
{
    addPluginParameter (new slParameter (paramWave1,        "Pulse 1 Wave",       "Wave",       "", 0.0f, 4.0f,  1.0f, 1.0f, 1.0f, waveTextFunction));
    addPluginParameter (new slParameter (paramPulseWidth1,  "Pulse 1 Duty Cycle", "D.C.",       "", 0.0f, 4095.0f,  1.0f, 2048.0f, 1.0f, dutyCycleTextFunction));
    addPluginParameter (new slParameter (paramA1,           "Pulse 1 A",          "A",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, aTextFunction));
    addPluginParameter (new slParameter (paramD1,           "Pulse 1 D",          "D",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new slParameter (paramS1,           "Pulse 1 S",          "S",          "", 0.0f, 15.0f, 1.0f, 8.0f, 1.0f, sTextFunction));
    addPluginParameter (new slParameter (paramR1,           "Pulse 1 R",          "R",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));

    addPluginParameter (new slParameter (paramWave2,        "Pulse 2 Wave",       "Wave",       "", 0.0f, 4.0f,  1.0f, 0.0f, 1.0f, waveTextFunction));
    addPluginParameter (new slParameter (paramPulseWidth2,  "Pulse 2 Duty Cycle", "D.C.",       "", 0.0f, 4095.0f,  1.0f, 2048.0f, 1.0f, dutyCycleTextFunction));
    addPluginParameter (new slParameter (paramA2,           "Pulse 2 A",          "A",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, aTextFunction));
    addPluginParameter (new slParameter (paramD2,           "Pulse 2 D",          "D",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new slParameter (paramS2,           "Pulse 2 S",          "S",          "", 0.0f, 15.0f, 1.0f, 8.0f, 1.0f, sTextFunction));
    addPluginParameter (new slParameter (paramR2,           "Pulse 2 R",          "R",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));

    addPluginParameter (new slParameter (paramWave3,        "Pulse 3 Wave",       "Wave",       "", 0.0f, 4.0f,  1.0f, 0.0f, 1.0f, waveTextFunction));
    addPluginParameter (new slParameter (paramPulseWidth3,  "Pulse 3 Duty Cycle", "D.C.",       "", 0.0f, 4095.0f,  1.0f, 2048.0f, 1.0f, dutyCycleTextFunction));
    addPluginParameter (new slParameter (paramA3,           "Pulse 3 A",          "A",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, aTextFunction));
    addPluginParameter (new slParameter (paramD3,           "Pulse 3 D",          "D",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new slParameter (paramS3,           "Pulse 3 S",          "S",          "", 0.0f, 15.0f, 1.0f, 8.0f, 1.0f, sTextFunction));
    addPluginParameter (new slParameter (paramR3,           "Pulse 3 R",          "R",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    
    addPluginParameter (new slParameter (paramVol,          "Volume",             "Volume",     "", 0.0f, 15.0f, 1.0f, 10.0f, 1.0f));
}

SIDAudioProcessor::~SIDAudioProcessor()
{
}

//==============================================================================
void SIDAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    outputSmoothed.reset (sampleRate, 0.05);
    
    sid.set_chip_model (MOS6581);
    
    sid.set_sampling_parameters (1022730, SAMPLE_INTERPOLATE, sampleRate);
}

void SIDAudioProcessor::releaseResources()
{
}

void SIDAudioProcessor::runUntil (int& done, AudioSampleBuffer& buffer, int pos)
{
    int todo = jmin (pos, buffer.getNumSamples()) - done;
    
    while (todo > 0)
    {
        cycle_count clock = 64;
        while (clock)
        {
            short out[1024];
            int count = sid.clock (clock, out, 1024);
            
            float* data = buffer.getWritePointer (0, done);
            for (int i = 0; i < count; i++)
                data[i] = out[i] / 32768.0f;
        
            done += count;
            todo -= count;
        }
    }
}

void SIDAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midi)
{
    int done = 0;
    runUntil (done, buffer, 0);
    
    int pos = 0;
    MidiMessage msg;
    MidiBuffer::Iterator itr (midi);
    while (itr.getNextEvent (msg, pos))
    {
        runUntil (done, buffer, pos);
        
        if (msg.isNoteOn())
        {
            noteQueue.add (msg.getNoteNumber());
            velocity = msg.getVelocity();
        }
        else if (msg.isNoteOff())
        {
            noteQueue.removeFirstMatchingValue (msg.getNoteNumber());
        }
        else if (msg.isAllNotesOff())
        {
            noteQueue.clear();
        }
        
        const int curNote = noteQueue.size() > 0 ? noteQueue.getFirst() : -1;
        
        if (curNote != lastNote)
        {
            // Channel 1
            if (curNote != -1 && parameterIntValue (paramWave1))
            {
                // set adsr
                int a = parameterValue (paramA1);
                int d = parameterValue (paramD1);
                int s = parameterValue (paramS1);
                int r = parameterValue (paramR1);
                
                sid.write (0x05, (a << 4) | d);
                sid.write (0x06, (s << 4) | r);
                
                // set duty
                int duty = 4095 - parameterValue (paramPulseWidth1);
                sid.write (0x02, duty & 0xFF);
                sid.write (0x03, duty >> 8);
                
                // set freq
                float freq = MidiMessage::getMidiNoteInHertz (curNote);
                int period = freq * (14 * pow (2, 24)) / 14318182;
                
                sid.write (0x00, period & 0xFF);
                sid.write (0x01, period >> 8);
                
                // set wave on
                uint8_t waveType = parameterIntValue (paramWave1);
                uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
                sid.write (0x04, (wave << 4) | 0x01);
            }
            else
            {
                // set wave off
                uint8_t waveType = parameterIntValue (paramWave1);
                uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
                sid.write (0x04, (wave << 4) | 0x00);
            }

            // Channel 2
            if (curNote != -1 && parameterIntValue (paramWave2))
            {
                // set adsr
                int a = parameterValue (paramA2);
                int d = parameterValue (paramD2);
                int s = parameterValue (paramS2);
                int r = parameterValue (paramR2);
                
                sid.write (0x0C, (a << 4) | d);
                sid.write (0x0D, (s << 4) | r);
                
                // set duty
                int duty = 4095 - parameterValue (paramPulseWidth2);
                sid.write (0x09, duty & 0xFF);
                sid.write (0x0A, duty >> 8);
                
                // set freq
                float freq = MidiMessage::getMidiNoteInHertz (curNote);
                int period = freq * (14 * pow (2, 24)) / 14318182;
                
                sid.write (0x07, period & 0xFF);
                sid.write (0x08, period >> 8);
                
                // set wave on
                uint8_t waveType = parameterIntValue (paramWave2);
                uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
                sid.write (0x0B, (wave << 4) | 0x01);
            }
            else
            {
                // set wave off
                uint8_t waveType = parameterIntValue (paramWave2);
                uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
                sid.write (0x0B, (wave << 4) | 0x00);
            }
            
            // Channel 3
            if (curNote != -1 && parameterIntValue (paramWave3))
            {
                // set adsr
                int a = parameterValue (paramA3);
                int d = parameterValue (paramD3);
                int s = parameterValue (paramS3);
                int r = parameterValue (paramR3);
                
                sid.write (0x13, (a << 4) | d);
                sid.write (0x14, (s << 4) | r);
                
                // set duty
                int duty = 4095 - parameterValue (paramPulseWidth3);
                sid.write (0x10, duty & 0xFF);
                sid.write (0x11, duty >> 8);
                
                // set freq
                float freq = MidiMessage::getMidiNoteInHertz (curNote);
                int period = freq * (14 * pow (2, 24)) / 14318182;
                
                sid.write (0x0E, period & 0xFF);
                sid.write (0x0F, period >> 8);
                
                // set wave on
                uint8_t waveType = parameterIntValue (paramWave3);
                uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
                sid.write (0x12, (wave << 4) | 0x01);
            }
            else
            {
                // set wave off
                uint8_t waveType = parameterIntValue (paramWave3);
                uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
                sid.write (0x12, (wave << 4) | 0x00);
            }
            
            sid.write (0x18, parameterIntValue (paramVol));
            
            lastNote = curNote;
        }
    }
    
    runUntil (done, buffer, buffer.getNumSamples());
    
    float* data = buffer.getWritePointer (0);
    
    if (editor)
        editor->scope.addSamples (data, buffer.getNumSamples());
}

//==============================================================================
bool SIDAudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* SIDAudioProcessor::createEditor()
{
    editor = new SIDAudioProcessorEditor (*this);
    return editor;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new SIDAudioProcessor();
}
