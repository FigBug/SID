/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

const char* SIDAudioProcessor::paramPulseWidth1 = "pw1";
const char* SIDAudioProcessor::paramWave1       = "w1";
const char* SIDAudioProcessor::paramA1          = "a1";
const char* SIDAudioProcessor::paramD1          = "d1";
const char* SIDAudioProcessor::paramS1          = "s1";
const char* SIDAudioProcessor::paramR1          = "r1";
const char* SIDAudioProcessor::paramTune1       = "tune1";
const char* SIDAudioProcessor::paramFine1       = "fine1";
const char* SIDAudioProcessor::paramSync1       = "sync1";
const char* SIDAudioProcessor::paramRing1       = "ring1";

const char* SIDAudioProcessor::paramPulseWidth2 = "pw2";
const char* SIDAudioProcessor::paramWave2       = "w2";
const char* SIDAudioProcessor::paramA2          = "a2";
const char* SIDAudioProcessor::paramD2          = "d2";
const char* SIDAudioProcessor::paramS2          = "s2";
const char* SIDAudioProcessor::paramR2          = "r2";
const char* SIDAudioProcessor::paramTune2       = "tune2";
const char* SIDAudioProcessor::paramFine2       = "fine2";
const char* SIDAudioProcessor::paramSync2       = "sync2";
const char* SIDAudioProcessor::paramRing2       = "ring2";

const char* SIDAudioProcessor::paramPulseWidth3 = "pw3";
const char* SIDAudioProcessor::paramWave3       = "w3";
const char* SIDAudioProcessor::paramA3          = "a3";
const char* SIDAudioProcessor::paramD3          = "d3";
const char* SIDAudioProcessor::paramS3          = "s3";
const char* SIDAudioProcessor::paramR3          = "r3";
const char* SIDAudioProcessor::paramTune3       = "tune3";
const char* SIDAudioProcessor::paramFine3       = "fine3";
const char* SIDAudioProcessor::paramSync3       = "sync3";
const char* SIDAudioProcessor::paramRing3       = "ring3";

const char* SIDAudioProcessor::paramCutoff      = "cutoff";
const char* SIDAudioProcessor::paramReso        = "reso";
const char* SIDAudioProcessor::paramFilter1     = "f1";
const char* SIDAudioProcessor::paramFilter2     = "f2";
const char* SIDAudioProcessor::paramFilter3     = "f3";
const char* SIDAudioProcessor::paramLP          = "lowpass";
const char* SIDAudioProcessor::paramBP          = "bandpass";
const char* SIDAudioProcessor::paramHP          = "highpass";

const char* SIDAudioProcessor::paramVol         = "vol";
const char* SIDAudioProcessor::paramOutput3     = "output3";

//==============================================================================
String percentTextFunction (const slParameter& p, float userValue)
{
    return String::formatted ("%.0f%%", userValue / p.getUserRangeEnd() * 100);
}

String wholeNumberTextFunction (const slParameter& p, float userValue)
{
    return String::formatted ("%.0f", userValue);
}

String dutyCycleTextFunction (const slParameter&, float userValue)
{
    return String::formatted ("%.0f%%", userValue / 4095.0 * 100);
}

String typeTextFunction (const slParameter&, float userValue)
{
    return userValue > 0.0f ? "White" : "Periodic";
}

String filterTextFunction (const slParameter&, float userValue)
{
    return userValue > 0.0f ? "Filter" : "Bypass";
}

String onOffTextFunction (const slParameter&, float userValue)
{
    return userValue > 0.0f ? "On" : "Off";
}

String waveTextFunction (const slParameter&, float userValue)
{
    switch (int (userValue))
    {
        case 0: return "Off";
        case 1: return "Triangle";
        case 2: return "Saw";
        case 3: return "Square";
        case 4: return "Noise";
    }
    return "";
}

String aTextFunction (const slParameter&, float userValue)
{
    switch (int (userValue))
    {
        case 0: return "2 ms";
        case 1: return "8 ms";
        case 2: return "16 ms";
        case 3: return "24 ms";
        case 4: return "38 ms";
        case 5: return "56 ms";
        case 6: return "68 ms";
        case 7: return "80 ms";
        case 8: return "100 ms";
        case 9: return "240 ms";
        case 10: return "500 ms";
        case 11: return "800 ms";
        case 12: return "1 s";
        case 13: return "3 s";
        case 14: return "5 s";
        case 15: return "8 s";
        default: return "";
    }
}

String drTextFunction (const slParameter&, float userValue)
{
    switch (int (userValue))
    {
        case 0: return "6 ms";
        case 1: return "24 ms";
        case 2: return "48 ms";
        case 3: return "72 ms";
        case 4: return "114 ms";
        case 5: return "168 ms";
        case 6: return "204 ms";
        case 7: return "240 ms";
        case 8: return "300 ms";
        case 9: return "750 ms";
        case 10: return "1.5 s";
        case 11: return "2.4 s";
        case 12: return "3 s";
        case 13: return "9 s";
        case 14: return "15 s";
        case 15: return "24 s";
        default: return "";
    }
}

String sTextFunction (const slParameter&, float userValue)
{
    return String::formatted ("%.0f%%", userValue / 15 * 100);
}

//==============================================================================
SIDAudioProcessor::SIDAudioProcessor()
{
    auto cutoffTextFunction = [this] (const slParameter& p, float userValue) -> String
    {
        return String::formatted ("%d Hz", sid.regToCutoff (userValue));
    };
    
    addPluginParameter (new slParameter (paramWave1,        "Pulse 1 Wave",       "Wave",       "", 0.0f, 4.0f,  1.0f, 1.0f, 1.0f, waveTextFunction));
    addPluginParameter (new slParameter (paramPulseWidth1,  "Pulse 1 Pulse Width","PW",         "", 0.0f, 4095.0f,  1.0f, 2048.0f, 1.0f, dutyCycleTextFunction));
    addPluginParameter (new slParameter (paramA1,           "Pulse 1 A",          "A",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, aTextFunction));
    addPluginParameter (new slParameter (paramD1,           "Pulse 1 D",          "D",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new slParameter (paramS1,           "Pulse 1 S",          "S",          "", 0.0f, 15.0f, 1.0f, 8.0f, 1.0f, sTextFunction));
    addPluginParameter (new slParameter (paramR1,           "Pulse 1 R",          "R",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new slParameter (paramTune1,        "Pulse 1 Tune",       "Tune",       "", -48.0f, 48.0f, 1.0f, 0.0f, 1.0f, wholeNumberTextFunction));
    addPluginParameter (new slParameter (paramFine1,        "Pulse 1 Fine",       "Fine",       "", -100.0f, 100.0f, 1.0f, 0.0f, 1.0f, wholeNumberTextFunction));
    addPluginParameter (new slParameter (paramSync1,        "Pulse 1 Sync",       "Sync 1<3",   "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new slParameter (paramRing1,        "Pulse 1 Ring",       "Ring 1<3",   "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));

    addPluginParameter (new slParameter (paramWave2,        "Pulse 2 Wave",       "Wave",       "", 0.0f, 4.0f,  1.0f, 0.0f, 1.0f, waveTextFunction));
    addPluginParameter (new slParameter (paramPulseWidth2,  "Pulse 2 Pulse Width","PW",         "", 0.0f, 4095.0f,  1.0f, 2048.0f, 1.0f, dutyCycleTextFunction));
    addPluginParameter (new slParameter (paramA2,           "Pulse 2 A",          "A",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, aTextFunction));
    addPluginParameter (new slParameter (paramD2,           "Pulse 2 D",          "D",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new slParameter (paramS2,           "Pulse 2 S",          "S",          "", 0.0f, 15.0f, 1.0f, 8.0f, 1.0f, sTextFunction));
    addPluginParameter (new slParameter (paramR2,           "Pulse 2 R",          "R",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new slParameter (paramTune2,        "Pulse 2 Tune",       "Tune",       "", -48.0f, 48.0f, 1.0f, 0.0f, 1.0f, wholeNumberTextFunction));
    addPluginParameter (new slParameter (paramFine2,        "Pulse 2 Fine",       "Fine",       "", -100.0f, 100.0f, 1.0f, 0.0f, 1.0f, wholeNumberTextFunction));
    addPluginParameter (new slParameter (paramSync2,        "Pulse 2 Sync",       "Sync 2<1",   "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new slParameter (paramRing2,        "Pulse 2 Ring",       "Ring 2<1",   "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));

    addPluginParameter (new slParameter (paramWave3,        "Pulse 3 Wave",       "Wave",       "", 0.0f, 4.0f,  1.0f, 0.0f, 1.0f, waveTextFunction));
    addPluginParameter (new slParameter (paramPulseWidth3,  "Pulse 3 Pulse Width","PW",         "", 0.0f, 4095.0f,  1.0f, 2048.0f, 1.0f, dutyCycleTextFunction));
    addPluginParameter (new slParameter (paramA3,           "Pulse 3 A",          "A",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, aTextFunction));
    addPluginParameter (new slParameter (paramD3,           "Pulse 3 D",          "D",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new slParameter (paramS3,           "Pulse 3 S",          "S",          "", 0.0f, 15.0f, 1.0f, 8.0f, 1.0f, sTextFunction));
    addPluginParameter (new slParameter (paramR3,           "Pulse 3 R",          "R",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new slParameter (paramTune3,        "Pulse 3 Tune",       "Tune",       "", -48.0f, 48.0f, 1.0f, 0.0f, 1.0f, wholeNumberTextFunction));
    addPluginParameter (new slParameter (paramFine3,        "Pulse 3 Fine",       "Fine",       "", -100.0f, 100.0f, 1.0f, 0.0f, 1.0f, wholeNumberTextFunction));
    addPluginParameter (new slParameter (paramSync3,        "Pulse 3 Sync",       "Sync 3<1",   "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new slParameter (paramRing3,        "Pulse 3 Ring",       "Ring 3<1",   "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));

    addPluginParameter (new slParameter (paramFilter1,      "Filter Ch 1",        "Ch 1",       "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, filterTextFunction));
    addPluginParameter (new slParameter (paramFilter2,      "Filter Ch 2",        "Ch 2",       "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, filterTextFunction));
    addPluginParameter (new slParameter (paramFilter3,      "Filter Ch 3",        "Ch 3",       "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, filterTextFunction));
    addPluginParameter (new slParameter (paramLP,           "Low Pass",           "LP",         "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new slParameter (paramBP,           "Band Pass",          "BP",         "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new slParameter (paramHP,           "High Pass",          "HP",         "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new slParameter (paramCutoff,       "Cutoff",             "Cutoff",     "Hz", 0.0f, 2047.0f, 1.0f, 1024.0f, 1.0f, cutoffTextFunction));
    addPluginParameter (new slParameter (paramReso,         "Resonance",          "Reso",       "", 0.0f, 15.0f, 1.0f, 8.0f, 1.0f, percentTextFunction));
    addPluginParameter (new slParameter (paramVol,          "Volume",             "Volume",     "", 0.0f, 15.0f, 1.0f, 10.0f, 1.0f, percentTextFunction));
    addPluginParameter (new slParameter (paramOutput3,      "Output 3",           "Output",     "", 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, onOffTextFunction));
}

SIDAudioProcessor::~SIDAudioProcessor()
{
}

//==============================================================================
void SIDAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    outputSmoothed.reset (sampleRate, 0.05);
    
    sid.set_chip_model (MOS6581);
    
    sid.set_sampling_parameters (1022730, SAMPLE_INTERPOLATE, sampleRate);
}

void SIDAudioProcessor::releaseResources()
{
}

void SIDAudioProcessor::runUntil (int& done, AudioSampleBuffer& buffer, int pos)
{
    int todo = jmin (pos, buffer.getNumSamples()) - done;
    
    while (todo > 0)
    {
        cycle_count clock = 64;
        while (clock)
        {
            short out[1024];
            int count = sid.clock (clock, out, 1024);
            
            float* data = buffer.getWritePointer (0, done);
            for (int i = 0; i < count; i++)
                data[i] = out[i] / 32768.0f;
        
            done += count;
            todo -= count;
        }
    }
}

void SIDAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midi)
{
    // Update the filters
    uint8_t reg;
    
    reg = parameterIntValue (paramCutoff) & 0x7;
    if (reg != last15)
        sid.write (0x15, last15 = reg);
    
    reg = parameterIntValue (paramCutoff) >> 3;
    if (reg != last16)
        sid.write (0x16, last16 = reg);
    
    reg = parameterIntValue (paramReso) << 4 |
          parameterIntValue (paramFilter3) << 2 |
          parameterIntValue (paramFilter2) << 1 |
          parameterIntValue (paramFilter1) << 0;
    
    if (reg != last17)
        sid.write (0x17, last17 = reg);
    
    reg = (parameterIntValue (paramOutput3) ? 0 : 1) << 7 |
           parameterIntValue(paramHP) << 6 |
           parameterIntValue(paramBP) << 5 |
           parameterIntValue(paramLP) << 4 |
           parameterIntValue (paramVol);
    
    if (reg != last18)
        sid.write (0x18, last18 = reg);
    
    int done = 0;
    runUntil (done, buffer, 0);
    
    int pos = 0;
    MidiMessage msg;
    MidiBuffer::Iterator itr (midi);
    while (itr.getNextEvent (msg, pos))
    {
        runUntil (done, buffer, pos);
        
        if (msg.isNoteOn())
        {
            noteQueue.add (msg.getNoteNumber());
            velocity = msg.getVelocity();
        }
        else if (msg.isNoteOff())
        {
            noteQueue.removeFirstMatchingValue (msg.getNoteNumber());
        }
        else if (msg.isAllNotesOff())
        {
            noteQueue.clear();
        }
        
        const int curNote = noteQueue.size() > 0 ? noteQueue.getFirst() : -1;
        
        if (curNote != lastNote)
        {
            // Channel 1
            if (curNote != -1 && parameterIntValue (paramWave1))
            {
                // set adsr
                int a = parameterValue (paramA1);
                int d = parameterValue (paramD1);
                int s = parameterValue (paramS1);
                int r = parameterValue (paramR1);
                
                sid.write (0x05, (a << 4) | d);
                sid.write (0x06, (s << 4) | r);
                
                // set duty
                int duty = 4095 - parameterValue (paramPulseWidth1);
                sid.write (0x02, duty & 0xFF);
                sid.write (0x03, duty >> 8);
                
                // set freq
                float freq = getMidiNoteInHertz (curNote + parameterValue (paramTune1) + parameterValue (paramFine1) / 100.0f);
                int period = freq * (14 * pow (2, 24)) / 14318182;
                
                sid.write (0x00, period & 0xFF);
                sid.write (0x01, period >> 8);
                
                // set wave on
                uint8_t waveType = parameterIntValue (paramWave1);
                uint8_t sync = parameterValue (paramSync1) ? 0x02 : 0x00;
                uint8_t ring = parameterValue (paramRing1) ? 0x04 : 0x00;
                uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
                sid.write (0x04, (wave << 4) | sync | ring | 0x01);
            }
            else
            {
                // set wave off
                uint8_t waveType = parameterIntValue (paramWave1);
                uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
                sid.write (0x04, (wave << 4) | 0x00);
            }

            // Channel 2
            if (curNote != -1 && parameterIntValue (paramWave2))
            {
                // set adsr
                int a = parameterValue (paramA2);
                int d = parameterValue (paramD2);
                int s = parameterValue (paramS2);
                int r = parameterValue (paramR2);
                
                sid.write (0x0C, (a << 4) | d);
                sid.write (0x0D, (s << 4) | r);
                
                // set duty
                int duty = 4095 - parameterValue (paramPulseWidth2);
                sid.write (0x09, duty & 0xFF);
                sid.write (0x0A, duty >> 8);
                
                // set freq
                float freq = getMidiNoteInHertz (curNote + parameterValue (paramTune2) + parameterValue (paramFine2) / 100.0f);
                int period = freq * (14 * pow (2, 24)) / 14318182;
                
                sid.write (0x07, period & 0xFF);
                sid.write (0x08, period >> 8);
                
                // set wave on
                uint8_t waveType = parameterIntValue (paramWave2);
                uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
                uint8_t sync = parameterValue (paramSync2) ? 0x02 : 0x00;
                uint8_t ring = parameterValue (paramRing2) ? 0x04 : 0x00;
                sid.write (0x0B, (wave << 4) | sync | ring | 0x01);
            }
            else
            {
                // set wave off
                uint8_t waveType = parameterIntValue (paramWave2);
                uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
                sid.write (0x0B, (wave << 4) | 0x00);
            }
            
            // Channel 3
            if (curNote != -1 && parameterIntValue (paramWave3))
            {
                // set adsr
                int a = parameterValue (paramA3);
                int d = parameterValue (paramD3);
                int s = parameterValue (paramS3);
                int r = parameterValue (paramR3);
                
                sid.write (0x13, (a << 4) | d);
                sid.write (0x14, (s << 4) | r);
                
                // set duty
                int duty = 4095 - parameterValue (paramPulseWidth3);
                sid.write (0x10, duty & 0xFF);
                sid.write (0x11, duty >> 8);
                
                // set freq
                float freq = getMidiNoteInHertz (curNote + parameterValue (paramTune3) + parameterValue (paramFine3) / 100.0f);
                int period = freq * (14 * pow (2, 24)) / 14318182;
                
                sid.write (0x0E, period & 0xFF);
                sid.write (0x0F, period >> 8);
                
                // set wave on
                uint8_t waveType = parameterIntValue (paramWave3);
                uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
                uint8_t sync = parameterValue (paramSync3) ? 0x02 : 0x00;
                uint8_t ring = parameterValue (paramRing3) ? 0x04 : 0x00;
                sid.write (0x12, (wave << 4) | sync | ring | 0x01);
            }
            else
            {
                // set wave off
                uint8_t waveType = parameterIntValue (paramWave3);
                uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
                sid.write (0x12, (wave << 4) | 0x00);
            }
            
            lastNote = curNote;
        }
    }
    
    runUntil (done, buffer, buffer.getNumSamples());
    
    float* data = buffer.getWritePointer (0);
    
    if (editor)
        editor->scope.addSamples (data, buffer.getNumSamples());
}

//==============================================================================
bool SIDAudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* SIDAudioProcessor::createEditor()
{
    editor = new SIDAudioProcessorEditor (*this);
    return editor;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new SIDAudioProcessor();
}
