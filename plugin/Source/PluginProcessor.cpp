/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

using namespace gin;

const char* SIDAudioProcessor::paramPulseWidth1 = "pw1";
const char* SIDAudioProcessor::paramWave1       = "w1";
const char* SIDAudioProcessor::paramA1          = "a1";
const char* SIDAudioProcessor::paramD1          = "d1";
const char* SIDAudioProcessor::paramS1          = "s1";
const char* SIDAudioProcessor::paramR1          = "r1";
const char* SIDAudioProcessor::paramTune1       = "tune1";
const char* SIDAudioProcessor::paramFine1       = "fine1";
const char* SIDAudioProcessor::paramSync1       = "sync1";
const char* SIDAudioProcessor::paramRing1       = "ring1";

const char* SIDAudioProcessor::paramPulseWidth2 = "pw2";
const char* SIDAudioProcessor::paramWave2       = "w2";
const char* SIDAudioProcessor::paramA2          = "a2";
const char* SIDAudioProcessor::paramD2          = "d2";
const char* SIDAudioProcessor::paramS2          = "s2";
const char* SIDAudioProcessor::paramR2          = "r2";
const char* SIDAudioProcessor::paramTune2       = "tune2";
const char* SIDAudioProcessor::paramFine2       = "fine2";
const char* SIDAudioProcessor::paramSync2       = "sync2";
const char* SIDAudioProcessor::paramRing2       = "ring2";

const char* SIDAudioProcessor::paramPulseWidth3 = "pw3";
const char* SIDAudioProcessor::paramWave3       = "w3";
const char* SIDAudioProcessor::paramA3          = "a3";
const char* SIDAudioProcessor::paramD3          = "d3";
const char* SIDAudioProcessor::paramS3          = "s3";
const char* SIDAudioProcessor::paramR3          = "r3";
const char* SIDAudioProcessor::paramTune3       = "tune3";
const char* SIDAudioProcessor::paramFine3       = "fine3";
const char* SIDAudioProcessor::paramSync3       = "sync3";
const char* SIDAudioProcessor::paramRing3       = "ring3";

const char* SIDAudioProcessor::paramCutoff      = "cutoff";
const char* SIDAudioProcessor::paramReso        = "reso";
const char* SIDAudioProcessor::paramFilter1     = "f1";
const char* SIDAudioProcessor::paramFilter2     = "f2";
const char* SIDAudioProcessor::paramFilter3     = "f3";
const char* SIDAudioProcessor::paramLP          = "lowpass";
const char* SIDAudioProcessor::paramBP          = "bandpass";
const char* SIDAudioProcessor::paramHP          = "highpass";

const char* SIDAudioProcessor::paramVol         = "vol";
const char* SIDAudioProcessor::paramOutput3     = "output3";

//==============================================================================
String percentTextFunction (const Parameter& p, float userValue)
{
    return String::formatted ("%.0f%%", userValue / p.getUserRangeEnd() * 100);
}

String wholeNumberTextFunction (const Parameter&, float userValue)
{
    return String::formatted ("%.0f", userValue);
}

String dutyCycleTextFunction (const Parameter&, float userValue)
{
    return String::formatted ("%.0f%%", userValue / 4095.0 * 100);
}

String typeTextFunction (const Parameter&, float userValue)
{
    return userValue > 0.0f ? "White" : "Periodic";
}

String filterTextFunction (const Parameter&, float userValue)
{
    return userValue > 0.0f ? "Filter" : "Bypass";
}

String onOffTextFunction (const Parameter&, float userValue)
{
    return userValue > 0.0f ? "On" : "Off";
}

String waveTextFunction (const Parameter&, float userValue)
{
    switch (int (userValue))
    {
        case 0: return "Off";
        case 1: return "Triangle";
        case 2: return "Saw";
        case 3: return "Square";
        case 4: return "Noise";
    }
    return "";
}

String aTextFunction (const Parameter&, float userValue)
{
    switch (int (userValue))
    {
        case 0: return "2 ms";
        case 1: return "8 ms";
        case 2: return "16 ms";
        case 3: return "24 ms";
        case 4: return "38 ms";
        case 5: return "56 ms";
        case 6: return "68 ms";
        case 7: return "80 ms";
        case 8: return "100 ms";
        case 9: return "240 ms";
        case 10: return "500 ms";
        case 11: return "800 ms";
        case 12: return "1 s";
        case 13: return "3 s";
        case 14: return "5 s";
        case 15: return "8 s";
        default: return "";
    }
}

String drTextFunction (const Parameter&, float userValue)
{
    switch (int (userValue))
    {
        case 0: return "6 ms";
        case 1: return "24 ms";
        case 2: return "48 ms";
        case 3: return "72 ms";
        case 4: return "114 ms";
        case 5: return "168 ms";
        case 6: return "204 ms";
        case 7: return "240 ms";
        case 8: return "300 ms";
        case 9: return "750 ms";
        case 10: return "1.5 s";
        case 11: return "2.4 s";
        case 12: return "3 s";
        case 13: return "9 s";
        case 14: return "15 s";
        case 15: return "24 s";
        default: return "";
    }
}

String sTextFunction (const Parameter&, float userValue)
{
    return String::formatted ("%.0f%%", userValue / 15 * 100);
}

//==============================================================================
SIDAudioProcessor::SIDAudioProcessor()
{
    auto cutoffTextFunction = [this] (const Parameter&, float userValue) -> String
    {
        return String::formatted ("%d Hz", sid.regToCutoff (reg16 (userValue)));
    };
    
    addPluginParameter (new Parameter (paramWave1,        "Pulse 1 Wave",       "Wave",       "", 0.0f, 4.0f,  1.0f, 1.0f, 1.0f, waveTextFunction));
    addPluginParameter (new Parameter (paramPulseWidth1,  "Pulse 1 Pulse Width","PW",         "", 0.0f, 4095.0f,  1.0f, 2048.0f, 1.0f, dutyCycleTextFunction));
    addPluginParameter (new Parameter (paramA1,           "Pulse 1 A",          "A",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, aTextFunction));
    addPluginParameter (new Parameter (paramD1,           "Pulse 1 D",          "D",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new Parameter (paramS1,           "Pulse 1 S",          "S",          "", 0.0f, 15.0f, 1.0f, 8.0f, 1.0f, sTextFunction));
    addPluginParameter (new Parameter (paramR1,           "Pulse 1 R",          "R",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new Parameter (paramTune1,        "Pulse 1 Tune",       "Tune",       "", -48.0f, 48.0f, 1.0f, 0.0f, 1.0f, wholeNumberTextFunction));
    addPluginParameter (new Parameter (paramFine1,        "Pulse 1 Fine",       "Fine",       "", -100.0f, 100.0f, 1.0f, 0.0f, 1.0f, wholeNumberTextFunction));
    addPluginParameter (new Parameter (paramSync1,        "Pulse 1 Sync",       "Sync 1<3",   "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new Parameter (paramRing1,        "Pulse 1 Ring",       "Ring 1<3",   "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));

    addPluginParameter (new Parameter (paramWave2,        "Pulse 2 Wave",       "Wave",       "", 0.0f, 4.0f,  1.0f, 0.0f, 1.0f, waveTextFunction));
    addPluginParameter (new Parameter (paramPulseWidth2,  "Pulse 2 Pulse Width","PW",         "", 0.0f, 4095.0f,  1.0f, 2048.0f, 1.0f, dutyCycleTextFunction));
    addPluginParameter (new Parameter (paramA2,           "Pulse 2 A",          "A",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, aTextFunction));
    addPluginParameter (new Parameter (paramD2,           "Pulse 2 D",          "D",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new Parameter (paramS2,           "Pulse 2 S",          "S",          "", 0.0f, 15.0f, 1.0f, 8.0f, 1.0f, sTextFunction));
    addPluginParameter (new Parameter (paramR2,           "Pulse 2 R",          "R",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new Parameter (paramTune2,        "Pulse 2 Tune",       "Tune",       "", -48.0f, 48.0f, 1.0f, 0.0f, 1.0f, wholeNumberTextFunction));
    addPluginParameter (new Parameter (paramFine2,        "Pulse 2 Fine",       "Fine",       "", -100.0f, 100.0f, 1.0f, 0.0f, 1.0f, wholeNumberTextFunction));
    addPluginParameter (new Parameter (paramSync2,        "Pulse 2 Sync",       "Sync 2<1",   "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new Parameter (paramRing2,        "Pulse 2 Ring",       "Ring 2<1",   "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));

    addPluginParameter (new Parameter (paramWave3,        "Pulse 3 Wave",       "Wave",       "", 0.0f, 4.0f,  1.0f, 0.0f, 1.0f, waveTextFunction));
    addPluginParameter (new Parameter (paramPulseWidth3,  "Pulse 3 Pulse Width","PW",         "", 0.0f, 4095.0f,  1.0f, 2048.0f, 1.0f, dutyCycleTextFunction));
    addPluginParameter (new Parameter (paramA3,           "Pulse 3 A",          "A",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, aTextFunction));
    addPluginParameter (new Parameter (paramD3,           "Pulse 3 D",          "D",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new Parameter (paramS3,           "Pulse 3 S",          "S",          "", 0.0f, 15.0f, 1.0f, 8.0f, 1.0f, sTextFunction));
    addPluginParameter (new Parameter (paramR3,           "Pulse 3 R",          "R",          "", 0.0f, 15.0f, 1.0f, 4.0f, 1.0f, drTextFunction));
    addPluginParameter (new Parameter (paramTune3,        "Pulse 3 Tune",       "Tune",       "", -48.0f, 48.0f, 1.0f, 0.0f, 1.0f, wholeNumberTextFunction));
    addPluginParameter (new Parameter (paramFine3,        "Pulse 3 Fine",       "Fine",       "", -100.0f, 100.0f, 1.0f, 0.0f, 1.0f, wholeNumberTextFunction));
    addPluginParameter (new Parameter (paramSync3,        "Pulse 3 Sync",       "Sync 3<1",   "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new Parameter (paramRing3,        "Pulse 3 Ring",       "Ring 3<1",   "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));

    addPluginParameter (new Parameter (paramFilter1,      "Filter Ch 1",        "Ch 1",       "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, filterTextFunction));
    addPluginParameter (new Parameter (paramFilter2,      "Filter Ch 2",        "Ch 2",       "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, filterTextFunction));
    addPluginParameter (new Parameter (paramFilter3,      "Filter Ch 3",        "Ch 3",       "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, filterTextFunction));
    addPluginParameter (new Parameter (paramLP,           "Low Pass",           "LP",         "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new Parameter (paramBP,           "Band Pass",          "BP",         "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new Parameter (paramHP,           "High Pass",          "HP",         "", 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new Parameter (paramCutoff,       "Cutoff",             "Cutoff",     "Hz", 0.0f, 2047.0f, 1.0f, 1024.0f, 1.0f, cutoffTextFunction));
    addPluginParameter (new Parameter (paramReso,         "Resonance",          "Reso",       "", 0.0f, 15.0f, 1.0f, 8.0f, 1.0f, percentTextFunction));
    addPluginParameter (new Parameter (paramVol,          "Volume",             "Volume",     "", 0.0f, 15.0f, 1.0f, 10.0f, 1.0f, percentTextFunction));
    addPluginParameter (new Parameter (paramOutput3,      "Output 3",           "Output",     "", 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, onOffTextFunction));
}

SIDAudioProcessor::~SIDAudioProcessor()
{
}

//==============================================================================
void SIDAudioProcessor::prepareToPlay (double sampleRate, int)
{
    outputSmoothed.reset (sampleRate, 0.05);
    
    sid.reset();
    sid.set_chip_model (MOS6581);
    sid.set_sampling_parameters (1022730, SAMPLE_INTERPOLATE, sampleRate);
    
    outputFilter.setCoefficients (IIRCoefficients::makeHighPass (sampleRate, 10));
}

void SIDAudioProcessor::releaseResources()
{
}

void SIDAudioProcessor::runUntil (int& done, AudioSampleBuffer& buffer, int pos)
{
    int todo = jmin (pos, buffer.getNumSamples()) - done;
    
    while (todo > 0)
    {
        cycle_count clock = 64;
        while (clock && todo > 0)
        {
            short out[1024];
            int count = sid.clock (clock, out, jmin (todo, 1024));
            
            float* data = buffer.getWritePointer (0, done);
            for (int i = 0; i < count; i++)
                data[i] = out[i] / 32768.0f;
        
            done += count;
            todo -= count;
        }
    }
}

void SIDAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midi)
{
    // Update the filters
    uint8_t reg;
    
    reg = parameterIntValue (paramCutoff) & 0x7;
    writeReg (0x15, reg);
    
    reg = uint8_t (parameterIntValue (paramCutoff) >> 3);
    writeReg (0x16, reg);
    
    reg = uint8_t (parameterIntValue (paramReso) << 4 |
                   parameterIntValue (paramFilter3) << 2 |
                   parameterIntValue (paramFilter2) << 1 |
                   parameterIntValue (paramFilter1) << 0);
    
    writeReg (0x17, reg);
    
    reg = uint8_t ((parameterIntValue (paramOutput3) ? 0 : 1) << 7 |
                    parameterIntValue(paramHP) << 6 |
                    parameterIntValue(paramBP) << 5 |
                    parameterIntValue(paramLP) << 4 |
                    parameterIntValue (paramVol));
    
    writeReg (0x18, reg);
    
    updateOscs (lastNote);
    
    int done = 0;
    runUntil (done, buffer, 0);
    
    int pos = 0;
    MidiMessage msg;
    MidiBuffer::Iterator itr (midi);
    while (itr.getNextEvent (msg, pos))
    {
        bool updateBend = false;
        runUntil (done, buffer, pos);
        
        if (msg.isNoteOn())
        {
            noteQueue.add (msg.getNoteNumber());
            velocity = msg.getVelocity();
        }
        else if (msg.isNoteOff())
        {
            noteQueue.removeFirstMatchingValue (msg.getNoteNumber());
        }
        else if (msg.isAllNotesOff())
        {
            noteQueue.clear();
            pitchBend = 0;
        }
        else if (msg.isPitchWheel())
        {
            updateBend = true;
            pitchBend = (msg.getPitchWheelValue() - 8192) / 8192.0f * 2;
        }
        
        const int curNote = noteQueue.size() > 0 ? noteQueue.getLast() : -1;
        
        if (updateBend)
        {
            float freq;
            int period;
            
            // set freq 1
            freq = float (getMidiNoteInHertz (curNote + pitchBend + parameterValue (paramTune1) + parameterValue (paramFine1) / 100.0f));
            period = int (freq * (14 * std::pow (2, 24)) / 14318182);
            
            writeReg (0x00, period & 0xFF);
            writeReg (0x01, period >> 8);
            
            // set freq
            freq = float (getMidiNoteInHertz (curNote + pitchBend + parameterValue (paramTune2) + parameterValue (paramFine2) / 100.0f));
            period = int (freq * (14 * pow (2, 24)) / 14318182);
            
            writeReg (0x07, period & 0xFF);
            writeReg (0x08, period >> 8);
            
            // set freq 3
            freq = float (getMidiNoteInHertz (curNote + pitchBend + parameterValue (paramTune3) + parameterValue (paramFine3) / 100.0f));
            period = int (freq * (14 * std::pow (2, 24)) / 14318182);
            
            writeReg (0x0E, period & 0xFF);
            writeReg (0x0F, period >> 8);
        }
        
        if (updateBend || lastNote != curNote)
        {
            updateOscs (curNote);
            lastNote = curNote;
        }
    }
    
    runUntil (done, buffer, buffer.getNumSamples());
    
    float* data = buffer.getWritePointer (0);
    outputFilter.processSamples (data, buffer.getNumSamples());
    
    ScopedLock sl (editorLock);
    if (editor)
        editor->scope.addSamples (data, buffer.getNumSamples());
}

void SIDAudioProcessor::updateOscs (int curNote)
{
    // Channel 1
    if (curNote != -1 && parameterIntValue (paramWave1))
    {
        // set adsr
        int a = parameterIntValue (paramA1);
        int d = parameterIntValue (paramD1);
        int s = parameterIntValue (paramS1);
        int r = parameterIntValue (paramR1);
        
        writeReg (0x05, (a << 4) | d);
        writeReg (0x06, (s << 4) | r);
        
        // set duty
        int duty = 4095 - parameterIntValue (paramPulseWidth1);
        writeReg (0x02, duty & 0xFF);
        writeReg (0x03, duty >> 8);
        
        // set freq
        float freq = float (getMidiNoteInHertz (curNote + pitchBend + parameterValue (paramTune1) + parameterValue (paramFine1) / 100.0f));
        int period = int (freq * (14 * pow (2, 24)) / 14318182);
        
        writeReg (0x00, period & 0xFF);
        writeReg (0x01, period >> 8);
        
        // set wave on
        uint8_t waveType = uint8_t (parameterIntValue (paramWave1));
        uint8_t sync = parameterValue (paramSync1) ? 0x02 : 0x00;
        uint8_t ring = parameterValue (paramRing1) ? 0x04 : 0x00;
        uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
        writeReg (0x04, (wave << 4) | sync | ring | 0x01);
    }
    else
    {
        // set wave off
        uint8_t waveType = uint8_t (parameterIntValue (paramWave1));
        uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
        writeReg (0x04, (wave << 4) | 0x00);
    }
    
    // Channel 2
    if (curNote != -1 && parameterIntValue (paramWave2))
    {
        // set adsr
        int a = parameterIntValue (paramA2);
        int d = parameterIntValue (paramD2);
        int s = parameterIntValue (paramS2);
        int r = parameterIntValue (paramR2);
        
        writeReg (0x0C, (a << 4) | d);
        writeReg (0x0D, (s << 4) | r);
        
        // set duty
        int duty = 4095 - parameterIntValue (paramPulseWidth2);
        writeReg (0x09, duty & 0xFF);
        writeReg (0x0A, duty >> 8);
        
        // set freq
        float freq = float (getMidiNoteInHertz (curNote + pitchBend + parameterValue (paramTune2) + parameterValue (paramFine2) / 100.0f));
        int period = int (freq * (14 * pow (2, 24)) / 14318182);
        
        writeReg (0x07, period & 0xFF);
        writeReg (0x08, period >> 8);
        
        // set wave on
        uint8_t waveType = uint8_t (parameterIntValue (paramWave2));
        uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
        uint8_t sync = parameterIntValue (paramSync2) ? 0x02 : 0x00;
        uint8_t ring = parameterIntValue (paramRing2) ? 0x04 : 0x00;
        writeReg (0x0B, (wave << 4) | sync | ring | 0x01);
    }
    else
    {
        // set wave off
        uint8_t waveType = uint8_t (parameterIntValue (paramWave2));
        uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
        writeReg (0x0B, (wave << 4) | 0x00);
    }
    
    // Channel 3
    if (curNote != -1 && parameterIntValue (paramWave3))
    {
        // set adsr
        int a = parameterIntValue (paramA3);
        int d = parameterIntValue (paramD3);
        int s = parameterIntValue (paramS3);
        int r = parameterIntValue (paramR3);
        
        writeReg (0x13, (a << 4) | d);
        writeReg (0x14, (s << 4) | r);
        
        // set duty
        int duty = 4095 - parameterIntValue (paramPulseWidth3);
        writeReg (0x10, duty & 0xFF);
        writeReg (0x11, duty >> 8);
        
        // set freq
        float freq = float (getMidiNoteInHertz (curNote + pitchBend + parameterValue (paramTune3) + parameterValue (paramFine3) / 100.0f));
        int period = int (freq * (14 * pow (2, 24)) / 14318182);
        
        writeReg (0x0E, period & 0xFF);
        writeReg (0x0F, period >> 8);
        
        // set wave on
        uint8_t waveType = uint8_t (parameterIntValue (paramWave3));
        uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
        uint8_t sync = parameterIntValue (paramSync3) ? 0x02 : 0x00;
        uint8_t ring = parameterIntValue (paramRing3) ? 0x04 : 0x00;
        writeReg (0x12, (wave << 4) | sync | ring | 0x01);
    }
    else
    {
        // set wave off
        uint8_t waveType = uint8_t (parameterIntValue (paramWave3));
        uint8_t wave = waveType ? (1 << (waveType - 1)) : 0;
        writeReg (0x12, (wave << 4) | 0x00);
    }
}

void SIDAudioProcessor::writeReg (uint8 reg, uint8 value)
{
    auto itr = regCache.find (reg);
    if (itr == regCache.end())
    {
        regCache[reg] = value;
        sid.write (reg, value);
    }
    else if (itr->second != value)
    {
        regCache[reg] = value;
        sid.write (reg, value);
    }
}

//==============================================================================
bool SIDAudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* SIDAudioProcessor::createEditor()
{
    editor = new SIDAudioProcessorEditor (*this);
    return editor;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new SIDAudioProcessor();
}
